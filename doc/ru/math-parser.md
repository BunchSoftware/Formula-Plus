# Парсер математических выражений

Данный парсер умеет производить расчеты для ваших целей. В него нужно загрузить необходимое выражение и он его расчитает.

### [Оглавление](index.md)

## Начало работы и установка целей

- Вычислять значение математического выражения, состоящего из чисел с плавающий точкой и математических операторов (-,+,/,*,^,sqrt,!,%).
- Учёт приоритета операторов.
- Учёт скобок.
- Унарные плюс и минус.
- Вычисление нескольких выражений, разделённых точкой с запятой (;).
- Встроенные константы (pi, e).
- Создание собственных констант с помощью оператора присваивания (=).
- Встроенные функции с переменным числом аргументов.
- Задание новых функций.
- Задание тригонометрических функций sin, cos, tan
- Алгеибрические функции log

Сам проект концептуально будет состоять из четырёх частей:
- Лексический анализатор. Преобразовывает входную строку в последовательность токенов.
- Синтаксический анализатор. Строит из токенов синтаксическое представление в виде постфиксной нотации. Делать это будем без рекурсии и таблиц, с помощью алгоритма сортировочной станции.
- Вычислитель. Вычисляет результат выражения на стековой машине.
- Собственно, интерпретатор. Служит фасадом для вышеперечисленных частей.

## Список трансфораций для разложения математического выражения на понятный язык компилятору

1. ({} → nil) Заменить отсутствие кода на код, использующий нулевое значение.
2. (nil → constant) Заменить нулевое значение константой.
3. (constant → constant+) Заменить простую константу более сложной (строку из одной буквы на строку из нескольких букв, к примеру).
4. (constant → scalar) Заменить константу на переменную, или аргумент.
5. (statement → statements) Добавить безусловный оператор (break, continue, return и подобное).
6. (unconditional → if) Разбить поток выполнения с помощью условного оператора.
7. (scalar → array) Заменить переменную/аргумент массивом.
8. (array → container) Заменить массив более сложным контейнером.
9. (statement → recursion) Заменить выражение рекурсией.
10. (if → for) Заменить условный оператор циклом.
11. (expression → function) Заменить выражение функцией.
12. (variable → assignment) Изменить значение переменной.

## Фундамент интепретатора

Интерпретатор — программа, выполняющая интерпретацию.

Интерпретация — построчный анализ, обработка и выполнение исходного кода программы или запроса.

Самое главное и важное в нашем интерпретаторе - это разбиение символов, понятных человеку, на переменные понятные компьютеру. Для этого нам сначала понадобиться лексический анализ, который будет распозновать символы, вводимые человеком и их преобразование в токены.

В информатике лексический анализ («токенизация») — процесс аналитического разбора входной последовательности символов на распознанные группы — лексемы — с целью получения на выходе идентифицированных последовательностей, называемых «токенами» (подобно группировке букв в словах).

``` c++
 // Преобразование из оператора в wstring - обьемных строка, строковый класс для обьемных символов
inline std::wstring ToString(const Operator &op) {
    static const std::unordered_map<Operator, std::wstring> opmap{
            { Operator::Plus, L"+" }, { Operator::Minus, L"-" },
            { Operator::Mul, L"*" }, { Operator::Div, L"/" },
            { Operator::LParen, L"(" }, { Operator::RParen, L")" },
            { Operator::UPlus, L"u+" }, { Operator::UMinus, L"u-" },
            { Operator::Procent, L"%" }, { Operator:: Exponentiation, L"^" },
            { Operator::Extraction, L"sqrt(" }, { Operator::Factorial, L"!" },
            { Operator::Sin, L"sin[" }, { Operator::Cos, L"cos(" },
            { Operator::Tan, L"tan(" }, { Operator::Log, L"log(" },
            { Operator::Pi, L"π" }, { Operator::E, L"e" },
    };
    return opmap.at(op);
}

// Преобразование из double в wstring - обьемных строка, строковый класс для обьемных символов
inline std::wstring ToString(const double &num) {
    return std::to_wstring(num);
}
```


Данные фунции нам понадобятся для обратного преобразрования. Операторы и числа в строку.

``` c++
struct TokenVisitor {

    // Посещение всех элеменов в массиве
    template<typename Iter> void VisitAll(Iter first, Iter last) {
        std::for_each(first, last, [this](const auto &token) { token->Accept(*this); });
    }

    virtual ~TokenVisitor() {}
    // Посещение токена с численным значением
    virtual void Visit(double) = 0;
    // Посещение токена с оператором
    virtual void Visit(Operator) = 0;
};
```

Абстрактная структура TokenVisitor для обработки. Когда используется этот паттерн ?
Когда имеется много объектов разнородных классов с разными интерфейсами и наследованиями, и требуется выполнить ряд операций над каждым из этих объектов. Когда классам необходимо добавить одинаковый набор операций без изменения этих классов.Когда часто добавляются новые операции к классам, при этом общая структура классов стабильна и практически не изменяется.

``` c++
struct TokenConcept {
    virtual ~TokenConcept() {}
    // Принимает Token Visitor для получения посещенных мест
    virtual void Accept(TokenVisitor &) const = 0;
    // Преобразование в wstring - широкая строка, строковый класс для широких символов
    virtual std::wstring ToString() const = 0;
    // Равен ли текущий токен другому токену
    virtual bool DispatchEquals(const TokenConcept &) const = 0;
    // Равен ли текущий токен числовому значению в другом токене
    virtual bool EqualsTo(double) const {
        return false;
    }
    // Равен ли текущий токен оператора в другом токене
    virtual bool EqualsTo(Operator) const {
        return false;
    }
};
```
Мы создаем основу для токена ``` TokenConcept ```. После этого мы будем производить наследование. Реализуем базовые перегрузки функций. Преобразовани в ```std::wstring ```. Равен ли текущий токен другому токену ``` DispatchEquals ```. Ранво ли число текущего токена другому значению числа ``` EqualsTo(double) ```.  Равен ли текущий токен оператора в другом токене оператора ``` EqualsTo(Operator) ```.

``` c++
// Создание типа Token
typedef std::shared_ptr<const TokenConcept> Token;

// Преобразование из Token в wstring - широкая строка, строковый класс для широких символов
inline std::wstring ToString(const Token &token) {
    return token->ToString();
}

// Оператор равенства двух сторон выражения
inline bool operator==(const Token &left, const Token &right) {
    return left->DispatchEquals(*right);
}

// Оператор равенства двух сторон выражения
template<typename T> bool operator==(const Token &left, const T &right) {
    return left->EqualsTo(right);
}
```

Создаем и выделяем память под тип ``` Token ```. ``` ToString ``` - преобразование токена в строковой тип. А также оператор ``` == ```, для проверки равенства двух токенов.

``` c++
// Главный токен с наследованием TokenConcept
template<typename T> struct GenericToken : TokenConcept {
    GenericToken(T payload) : m_payload(std::move(payload)) {}
    // Принимает Token Visitor для получения посещенных мест
    void Accept(TokenVisitor &visitor) const override {
        visitor.Visit(m_payload);
    }
    // Преобразование в wstring - широкая строка, строковый класс для широких символов
    std::wstring ToString() const override {
        return Interpreter::ToString(m_payload);
    }
     // Равен ли текущий токен числовому значению в другом токене
    bool EqualsTo(T value) const override {
        return value == m_payload;
    }
    // Равен ли текущий токен другому токену
    bool DispatchEquals(const TokenConcept &other) const override {
        return other.EqualsTo(m_payload);
    }

    T m_payload;
};
```

Реализация токена со сторон обобщения, наследуясь от ``` TokenConcept```

``` c++
using Detail::Token;

// Создание динамического массива Tokens
typedef std::vector<Token> Tokens;

// Создание токена из оператора
inline Token MakeToken(Operator value) {
    return std::make_shared<Detail::GenericToken<Operator>>(value);
}

// Создание токена из числового значения
inline Token MakeToken(double value) {
    return std::make_shared<Detail::GenericToken<double>>(value);
}
```

Создаем динамическиий массив ``` Tokens```. Создание токена из числа или оператора с помощью функции ``` MakeToken ```. Внутри фунции мы выделяем память на токен и делаем преобразование типов.

``` c++
class WithTokensResult {
public:
    // Вернуть результат набора токенов
    Tokens Result() {
        return std::move(m_result);
    }

protected:
    ~WithTokensResult() {}
    // Добавить значение к результату
    template<typename T> void AddToResult(T value) {
        m_result.push_back(MakeToken(value));
    }
    // Добавить токен к набору токенов
    void AddToResult(const Token &value) {
        m_result.push_back(value);
    }

private:
    Tokens m_result;
};
```
Данный класс отвечает за добавления токенов или других типов в наш динамический массив токенов.  ``` AddToResult ``` - добавляет токен или другой тип данных в динамический массив преобразую его в токен.


## Лексический анализатор

Пункты для правильного построения работы лексера
- В ответ на пустое выражение должен возвращаться пустой список токенов.
- В ответ на строку с оператором должен возвращаться токен с оператором.
- В ответ на строку с цифрой должен возвращаться токен с числом.
- В ответ на строку с числом с плавающей точкой должен возвращаться токен с этим числом.
- В ответ на строку с простым выражением должен возвращаться список соответствующих токенов.
- Пробелы между числами и операторами должны игнорироваться.

``` c++
 // Операторы для математических выражений
enum class Operator {
    Plus, Minus, Mul, Div, LParen, RParen, UPlus, UMinus, Procent,
    Exponentiation, Extraction, Factorial, Sin, Cos, Tan, Log, Pi, E,
};
```

Здесь перечислены все операторы, которые используюстся в нашем интерпретаторе. Они нам понадобяться, чтобы отмечать, например, символ "+". В вычислителе операторы будут производить вычисления.


``` c++
// Является ли символ числом
 bool IsNumber() const {
        return iswdigit(*m_current) != 0;
    }
```

Вспоминаем, что в стандартной библиотеке C есть такие функции, как isdigit, проверяющая, что данный символ является цифрой и atof, преобразующая строку в число, а также их аналоги для wchar_t. Применим (expression → function). 

``` c++
// Поиск и обработка числовых значений
    void ScanNumber() {
        AddToResult(wcstod(m_current, const_cast<wchar_t **>(&m_current)));
    }
```

Функция wcstod делает то же самое, что и _wtof, но также возвращает указатель на следующий за числом символ в строке. Так как все операторы на данный момент состоят из одного символа, то во втором случае просто передвигаем указатель на текущий символ на одну позицию вперёд.

``` c++
 // Является ли символ оператором
    bool IsOperator(){
        w_current.push_back(*m_current);
        return CharToOperatorMap().find(w_current) != CharToOperatorMap().end();
    }
```

Добавляем символ оператора, так как у нас есть операторы, состоящие не из одного символа, такие как sin или cos. Возвращаем истину, если в массиве операторов мы находим такой.

``` c++
 // Поиск и обработка операторов
    void ScanOperator() {
        AddToResult(CharToOperatorMap().at(w_current));
        w_current.clear();
        ++m_current;
    }
```

Добавляем оператор через указатель по строке, далее очищаем строку с оператором и смещаемся на один символ.

``` c++
 void Tokenize(const std::wstring &expression) {
        for(m_current = expression.c_str(); *m_current;) {
            // Является ли символ цифрой
            if(IsNumber())
                ScanNumber();
            // Является ли символ оператором
            else if(IsOperator())
                ScanOperator();
            // Пропускаем, если является пробелом или неопозноным обьектом
            else
              {
                ++m_current;
              }
        }
    }
```

Применим трансформацию (if → for). Можно было бы использовать рекурсию, но я решил целенаправленно делать не рекурсивный алгоритм. Применим (unconditional → if) добавив проверку на то, что символ является оператором. Нам нужно также разобраться с пробелами, теперь если нам попадается пробел, то мы просто смещаемся по указателю  на один символ вперед.


``` c++
 // Набор операторов
    static auto CharToOperatorMap() {
      static const std::unordered_map<std::wstring, Operator> opmap{
              {  L"+" , Operator::Plus}, { L"-", Operator::Minus},
              {  L"*" , Operator::Mul}, { L"/", Operator::Div},
              {  L"(" , Operator::LParen}, { L")", Operator::RParen},
              {  L"u+", Operator::UPlus}, { L"u-", Operator::UMinus},
              {  L"%" ,  Operator::Procent }, { L"^", Operator:: Exponentiation},
              {  L"sqrt(", Operator::Extraction}, { L"!", Operator::Factorial },
              {  L"sin(", Operator::Sin }, { L"cos(", Operator::Cos },
              {  L"tan(", Operator::Tan }, { L"log(", Operator::Log },
              {  L"π", Operator::Pi }, { L"e", Operator::E },
      };
        return opmap;
    }
```

Добавим необходимые операторы к перечислению Operator, чтобы использовать их для обазаначения. С помощью ``` std::unordered_map ``` мы задаем символы оператора, а во второе значение самого оператора, которое описано выше. Теперь эта функция будет возвращать нам определенный оператор по параметрам поиска в будущем.

``` c++
 // Набор операторов
 // Преобразование строкового значения wstring  в набор токенов
inline Tokens Tokenize(const std::wstring &expression) {
    Detail::Tokenizer tokenizer;
    tokenizer.Tokenize(expression);
    return tokenizer.Result();
}
```
Функция Tokenize просто будет служить фасадом для модуля лексера. В нее из другого модуля интепретатора будут поступать математические выражение, которые лексер будет успешно разбивать на токены

## Парсер

Парсер будет реализован по алгоритму сортировочной станции, так как он достаточно прост и не нуждается в рекурсии. Сам алгоритм таков:

В начале даются пустой выходной поток и пустой стек. Начнём читать токены из входного потока по очереди.

- Если это число, то передать его в выходной поток.
- Если это лево ассоциативный оператор, то выталкиваем токены из стека в выходной поток до тех пор, пока он не опустеет, либо на его вершине не встретится скобка, или оператор с более низким приоритетом.
- Если это открывающая скобка, то положить её в стек.
- Если это закрывающая скобка, то выталкиваем токены из стека в выходной поток до обнаружения открывающей скобки. Вытолкнуть открывающую скобку из стека, но не передавать её в выходной поток. Если стек опустел, и скобка не найдена, то генерируем ошибку.
- Если это закрывающая скобка, то выталкиваем токены из стека в выходной поток до обнаружения sin, cos, tan, log или другой функции. Вытолкнуть фунцию из стека, но не передавать её в выходной поток. Если стек опустел, и фунция не найдена, то генерируем ошибку.

``` c++
// Определение приоритетов в математическом выражении
template<typename T> int PrecedenceOf(const T &token) {
    if(token == Operator::UMinus) return 6;
    if(token == Operator::Pi || token == Operator::E) return 5;
    if(token == Operator::Exponentiation || token == Operator::Extraction) return 2;
    if(token == Operator::Mul || token == Operator::Div) return 4;
    if(token == Operator::Sin || token == Operator::Cos || token == Operator::Tan || token == Operator::Log) return 3;
    if(token == Operator::Exponentiation || token == Operator::Extraction) return 2;
    if(token == Operator::Procent) return 1;
    return 0;
}
```

В математике у каждого действия есть свои приоритеты. Например, умножение и деление выполняются раньше, чем сложение. Чем выше число приоритета, тем раньше оно стоит в коде.

1. Действие унарного минуса. Оно стоит всегда первым, так как нам нужно учитывать минус в независимости от действий в математическом выражении.
2. Константы Pi и E. Далее в вычислители, они просто заменяються за свои значения/
3. Извлечение корня и возведение в степень. Если у нас есть такой пример "10^2*10", мы сначало выполняем возведение в степепь и только потом расчет. Но если будет такое выражение "(10*10)^2", то мы в правильном математическом порядке, сначало расчитываем действия в скобка и только потом возводим в степень/
4. Действие умножение или деления. У них одинаковый приоритет.
5. Действие функций. Они производяться только тогкда, когда все выражение расчитано.
6. Расчет процента от выражение. Оно делается после расчета всего математического выражения.
7. Возвращаем остальные действия, которым не так важен порядок, например "+".

``` c++
// Посещение каждой части выражения и распределение операторов в правильном приоритете
    void Visit(Operator op) override {
        switch(op) {
            case Operator::UPlus:
                break;
            case Operator::UMinus:
            case Operator::LParen:
                PushCurrentToStack(op);
                break;
            case Operator::RParen:
                  if(UnaryOnTop() && isUnary == false)
                  {
                     isUnary = true;
                     break;
                  }
                  else if(m_stack.back() == Operator::RParen)
                  {
                      isUnary = true;
                      break;
                  }
                  else
                  {
                    PopToOutputUntil([this]() { return LeftParenOnTop(); });
                    PopLeftParen();
                    break;
                  }
            default:
                PopToOutputUntil([this, op]() { return LeftParenOnTop() || OperatorWithLessPrecedenceOnTop(op); });
                PushCurrentToStack(op);
                break;
        }
    }
```

Распределяем действия и сортируем в правильном порядке. Если это открывающая скобка, то добавляем ее в стек, а если это закрывающая скобка, то мы должны найти открывающиюся скобку и сместить их в выходной поток. Если при проверке нам не нужно, как-то особенно сортировать действия, то мы выталкиваем действия из потока и раставляем их в математическом приоритете.

``` c++
void Visit(double num) override {
        AddToResult(num);
    }
```

Добавляем число к нам в выражение, для расчета в Вычислителе.

``` c++
// Проверка на закрывающиюся скобку
    bool StackHasNoOperators() const {
        if(m_stack.back() == Operator::LParen) throw std::logic_error("Закрывающая скобка не найдена..");
        return false;
    }
```

Проверяем стек на наличие операторов. Если у нас будет, например, вот так "10*(", то нам выведет ошибку, а иначе вернет ложь. Это нам нужно для правильной обработки выражений и проверка на наличие ошибок со стороны ввода пользователя.


``` c++
void PushCurrentToStack(Operator op) {
        m_stack.push_back(MakeToken(op));
    }
```

Добавить оператор в текущий стек, для очередной проверки приоритетов в математическом выражении.

``` c++
    // Проверка на открывающиеся скобку
    void PopLeftParen() {
        if(m_stack.empty() || !LeftParenOnTop()) throw std::logic_error("Открывающая скобка не найдена.");
        m_stack.pop_back();
    }
```

Проверка на то, что наш стек уже пуст или последний элемент в стеке не открывающиеся скобка, тогда выведеться ошибка, а иначе удалиться последний элемент в стеке.

``` c++
// Оператор с меньшим приоритетом сверху
    bool OperatorWithLessPrecedenceOnTop(Operator op) const {
        return PrecedenceOf(m_stack.back()) < PrecedenceOf(op);
    }
```

Сравнивааем два оператора в стеке, текущий оператор, который передается в функцию и оператор последний в стеке. Если текущий оператор больше, то мы возвращаем истину. После чего функция ``` PopToOutputUntil() ``` успешно выталкнет наш оператор в выходной поток.

``` c++
// Левая скобка сверху
    bool LeftParenOnTop() const {
        return m_stack.back() == Operator::LParen;
    }
```

Проверка на то, что последний элемент в стеке являеться открывающийся скобкой.

``` c++
    template <typename T>
    void PopToOutputUntil(T whenToEnd) {
        while(!m_stack.empty() && !whenToEnd()) {
            AddToResult(m_stack.back());
            m_stack.pop_back();
        }
    }
```

Выталкивание в выходной поток до тех пор, если стек не пустой или мы дошли до ограничений. После чего, в наше итоговое выражение мы добавляем оператор, который мы сдвинули в конец по правилу приоритетов, а из стека мы удаляем этот оператор, чтобы повторно не расчитывать его.


``` c++
// Преобразование набора токенов в набор токенов
inline Tokens Parse(const Tokens &tokens) {
    Detail::ShuntingYardParser parser;
    parser.VisitAll(tokens.cbegin(), tokens.cend());
    return parser.Result();
}
```

Функция Parse просто будет служить фасадом для модуля парсера. В нее из другого модуля интепретатора будет поступать набор токенов, которые парсер будет успешно распределять с учетом приоритетов в математическом выражении.

## Вычислитель

Приступим к самому интересному. Вычисление выражения в постфиксной записи можно осуществить двумя способами: через рекурсию, неявно используя стек процесса, или используя явный стек. Реализуем второй вариант. Алгоритм с использованием явного стека такой:

- Если на вход подан операнд, он помещается на вершину стека.
- Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
- После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.

``` c++ 
template<typename T> static auto MakeEvaluator(const size_t arity, T function) {
        return [=](OpStack &stack) {
            if(stack.size() < arity) throw std::logic_error("Недостаточно аргументов в стеке.");
            Args argumentsOnStack = stack.cend() - arity;
            double result = function(argumentsOnStack);
            stack.erase(argumentsOnStack, stack.cend());
            stack.push_back(result);
        };
    }
```
Данная функция требуется для того, чтобы разбивать наш стек на аргументы, которые в будещем мы будем расчитывать по действиям в том порядке, который задается в стеке. После того, как мы произвили действие, в наш стек записываеться результат. И так до тех пор, пока все выражение не будет просчитано и у нас останеться только итоговоый ответ.
``` c++ 
// Обработка оператора при сложении двух переменных в математических выражениях
    void Visit(Operator op) override {
        const static std::unordered_map<Operator, std::function<void(OpStack &)>> evaluators{
                { Operator::Plus, MakeEvaluator(2, [=](Args a) { return a[0] + a[1]; }) },
                { Operator::Minus, MakeEvaluator(2, [=](Args a) { return a[0] - a[1]; }) },
                { Operator::Mul, MakeEvaluator(2, [=](Args a) { return a[0] * a[1]; }) },
                { Operator::Div, MakeEvaluator(2, [=](Args a) { return a[0] / a[1]; }) },
                { Operator::Procent, MakeEvaluator(1, [=](Args a) { return a[0]/100; }) },
                { Operator::Exponentiation, MakeEvaluator(2, [=](Args a) { return pow(a[0], a[1]); }) },
                { Operator::Extraction, MakeEvaluator(1, [=](Args a) { return sqrt(a[0]); }) },
                { Operator::Sin, MakeEvaluator(1, [=](Args a) { return sin(a[0]); }) },
                { Operator::Cos, MakeEvaluator(1, [=](Args a) { return cos(a[0]); }) },
                { Operator::Tan, MakeEvaluator(1, [=](Args a) { return tan(a[0]); }) },
                { Operator::Log, MakeEvaluator(1, [=](Args a) { return log(a[0]); }) },
                { Operator::Pi, MakeEvaluator(0, [=](Args a) { return 3.14159265358979323846; }) },
                { Operator::E, MakeEvaluator(0, [=](Args a) { return  2.71828182845904523536; }) }
        };
        evaluators.at(op)(m_stack);
    }
```

Совершаем действия в соответсвии с количеством аргументов, вызывая функцию ```MakeEvaluator```. Кажое действие обрабатываеться по математичским правилам и в итоге из двух значений, мы получаем только одно. Вместо констант, мы меняем на их значение. Все тригонометрические и алгеброические функции мы также расчитываем. Это происходит до тех пор, пока мы не придем к единому ответу.

``` c++ 
// Обработка числового значения в математических выражениях
    void Visit(double num) override {
        m_stack.push_back(num);
    }
```

Добавляем число в наш стек обработки.

``` c++ 
// Оценка набора токенов для преобразования в результат в виде числового значения
inline double Evaluate(const Tokens &tokens) {
    Detail::StackEvaluator evaluator;
    evaluator.VisitAll(tokens.cbegin(), tokens.cend());
    return evaluator.Result();
}
```

Функция Evaluate просто будет служить фасадом для модуля вычислителя. В нее из другого модуля интепретатора будет поступать набор токенов, которые вычислитель будет успешно решать и выводить итоговый результат, понятный пользователю.

## Все действия - всего в одной строчке кода

``` c++
// Интерпретировать строковое выражение в числовое значение
inline double InterpreteExperssion(const std::wstring &expression) {
    return Evaluator::Evaluate(Parser::Parse(Lexer::MarkUnaryOperators(Lexer::Tokenize(expression))));
}
```

Здесь мы обращаемся к Вычислителю, который обращается к Парсеру для преобразования выражения из токенов, который обращается к Лексеру, который расскладывает наше выражения на токены.

## Виды ошибок в интерпретаторе

1. Закрывающая скобка не найдена. Такая ошибка выведеться, если будет открывающиеся скобка, но будет закрывающийся скобки.
2. Открывающая скобка не найдена. Такая ошибка выведеться, если будет закрывающиеся скобка, но будет открывающийся скобки. 
3. Недостаточно аргументов в стеке. Когда в вычислитель попало каким-то образом аргументов  больше, чем в сам стек.
